import { sequelize } from '@auth/database';
import { IAuthDocument } from '@colson0x1/tradenexus-shared';
import { compare, hash } from 'bcryptjs';
import { DataTypes, Model, ModelDefined, Optional } from 'sequelize';

const SALT_ROUND = 10;

// @ Interface that extends the `Model` passing the properties that we
// want to pass.
// Create an interface that will extend Model. In that interface, add prototype
// and the prototype will have properties comparePassword and hashPassword.
// There's no need adding it into shared library because its only used in
// this schema
interface AuthModelInstanceMethods extends Model {
  // We want to add comparePassword and hashPassword and they both will be
  // properties of this prototype i.e AuthModel.prototype
  // prototype is of type Model
  // So here we set the property `prototype` which is an object and the object
  // contains comparePassword and hashPassword which is a method
  // comparePassword is a method that takes password of type string and
  // hashPassword of type string and it returns a promise of type boolean
  // and hashPassword is also a method which takes in password of type string and
  // returns a promise of type string.
  prototype: {
    comparePassword: (password: string, hashedPassword: string) => Promise<boolean>;
    hashPassword: (password: string) => Promise<string>;
  };
}

// This type will contain some optional types that we're not going to send
// when creating the users.
// `Optional` takes two properties. First one is the normal documents i.e
// IAuthDocument and the second part is where we define the properties that
// we're not going to send while creating the user. For example, im not going
// to send an ID. The `id` will be autogenerated. Also, i wont be sending
// `createdAt`. createdAt also will be autogenerated. And likewise,
// passwordResetToken and passwordResetExpires will be null.
type AuthUserCreationAttributes = Optional<IAuthDocument, 'id' | 'createdAt' | 'passwordResetToken' | 'passwordResetExpires'>;

// @ Auth Model
// Basically letting sequelize know that those properties on
// AuthUSerCreationAttributes are optional properties. So we can create the
// table or create the row for a user without adding those optional properties.
// They will be autogenerated.
const AuthModel: ModelDefined<IAuthDocument, AuthUserCreationAttributes> & AuthModelInstanceMethods = sequelize.define(
  'auths',
  {
    // The `id` will be automatically created and automatically indexed as
    // well.
    username: {
      type: DataTypes.STRING,
      allowNull: false
    },
    password: {
      type: DataTypes.STRING,
      allowNull: false
    },
    // This field is going to be the publicId that will be used to upload the
    // profile picture to Cloudinary
    profilePublicId: {
      type: DataTypes.STRING,
      allowNull: false
    },
    email: {
      type: DataTypes.STRING,
      allowNull: false
    },
    country: {
      type: DataTypes.STRING,
      allowNull: false
    },
    // profilePicture is going to be a string. Once uploaded to the Cloudinary,
    // we get a URL. So that URL will be added here. And we'll not allow it to
    // be empty.
    profilePicture: {
      type: DataTypes.STRING,
      allowNull: false
    },
    // emailVerificationToken is going to be string but we're going to allow it
    // to be null. So when the user creates an account, we've the field, we've
    // the token. Then once the user verifies the account, im going to set the
    // value to null.
    emailVerificationToken: {
      type: DataTypes.STRING,
      allowNull: true
    },
    // In MySQL, Booleans are represented with 0s and 1s.
    // Im gonna add a defaultValue of 0 i.e the user has not verified their
    // account.
    emailVerified: {
      type: DataTypes.BOOLEAN,
      allowNull: false,
      defaultValue: 0
    },
    createdAt: {
      type: DataTypes.DATE,
      // So at the time when the value is being added to the database, that is
      // what is going to be added as the createdAt date.
      defaultValue: Date.now
    },
    passwordResetToken: { type: DataTypes.STRING, allowNull: true },
    passwordResetExpires: {
      type: DataTypes.DATE,
      allowNull: false,
      // We can use `date.now` or `new Date()`
      defaultValue: new Date()
    }
  },
  {
    // The reasons i added indexes to these two fields is im 100% sure that,
    // im going to query by username and email.
    indexes: [
      {
        // indexes has to be unique because the emails will be unique
        unique: true,
        fields: ['email']
      },
      // Adding indexs to the username field too
      {
        unique: true,
        fields: ['username']
      },
      // adding index to also emailVerificationToken field because later im
      // going to search the table
      {
        unique: true,
        fields: ['emailVerificationToken']
      }
    ]
  }
) as ModelDefined<IAuthDocument, AuthUserCreationAttributes> & AuthModelInstanceMethods;

// `bcrypt` is written in C++ most likely and `bcryptjs` is written in plain
// JavaScript. Since bcryptjs is much slower than bcrypt, its recommended to
// use just `bcrypt` in production.
// bcrypt used to conflict with this node-gyp package with older node versions
// perhaps below v5. But the security issues has been resolved in v6 and modern
// versions.
// Both bcrypt and bcryptjs has the same methods. I recommend, bcrypt for
// production.
AuthModel.addHook('beforeCreate', async (auth: Model) => {
  // Hash password before the data is added to the table
  // `hashSync` is synchronous way of hashing and `hash` is asynchronous
  // We've to cast this `auth.dataValues.password` as a string because it
  // doesnt really know what type of `Model` i.e from (auth: Model), it
  // doesnt actually know what type of model it is. Im just setting the model.
  // But the `Model` will always return this `dataValues` and the `dataValues`
  // has the different properties i've defined  there in the 'auths' model
  // So all of those properties there are inside the `dataValues`.
  // `hash` takes two properties: string and the salt. salt is the number of
  // times its giong to hash the password. The higher the number, the higher
  // the number of times hashing algorithm is performed. If added very high
  // number, then when decrypting a password, its going to take a longer time.
  // So for example, if we add or use a salt round of 1 million, then when
  // its hashing the password, it will has it 1 million times. And then, if we
  // want to decrypt it, it will decrypt it. It will go through the round 1
  // million times. And that could be very, very slow.
  const hashedPassword: string = await hash(auth.dataValues.password as string, SALT_ROUND);
  // add hashed password back to the `password` property
  auth.dataValues.password = hashedPassword;
});

// This method will be used when we want to compare the user's password.
// i.e We want to use this method to compare if the user logs in because they
// will log in with their plain password. So before we allow them to log in,
// we're going to check the password i.e the plain text password they entered,
// to match the hashed password in the database. So, im going to do that
// with thie `compare` method from bcrypt!
// In hashing the function, if we try to use arrow fn, it returns some kind of
// errors.
AuthModel.prototype.comparePassword = async function (password: string, hashedPassword: string): Promise<boolean> {
  // If it match, it will return true else false
  return compare(password, hashedPassword);
};

AuthModel.prototype.hashPassword = async function (password: string): Promise<string> {
  return hash(password, SALT_ROUND);
};

// This will be used to create the table if the table does not exist. So once,
// server is started, this method `.sync()` will be called. It will check if
// the table exist. So it creates table but it the table exists, it will do
// nothing.
// note: `force: true` should only be used locally in the development if needed.
// like if maybe we want to clear all the data we have in the table and we want
// to create new data so new set of data. So in that case, we can set force to
// true.
// AuthModel.sync({ force: true });
// So if we set it this way, this means, everytime we restart our server,
// it will always drop the table and then create a new table. So don't use
// force. Only use it for testing.
// Hence, force always deletes the table when there is a server restart
AuthModel.sync({});
export { AuthModel };
